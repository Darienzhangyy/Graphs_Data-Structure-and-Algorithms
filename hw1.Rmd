---
output: pdf_document
---
Homework 1 - Eclectic Eagle Scouts
========================================================

```{r, echo=F}
source('graph.R')
```

## Auxiliary functions
This section demonstrates the workhorse functions powering the predicate and higher functions. Specifically, these allow one to convert list-based graph objects to adjacency matrices, to construct random graphs, to label and interpret mislabeled and unlabeled graphs, to check paths among all possible vertex pairs, to follow down and trace up paths, and to identify the minimally weighted path if these path sets intersect.

### ```adjacencyMatrix(g)```
Takes a list-based graph object and converts it to an adjacency matrix with the vertex labels as ```dimnames```. 
```{r}
adjacencyMatrix(graph1)
adjacencyMatrix(graph2)
adjacencyMatrix(graph2) %*% adjacencyMatrix(graph2)
```

### ```randomGraph(length, maxWeight=10, seed=NULL)```
Constructs ```graph```, a valid graph object with ```length``` vertices, labeled 1 to ```length```, and edge weights uniformly distributed from 1 to ```maxWeight```. Optionally, setting the ```seed``` allows one to reconstruct a previously generated graph, as ```seed``` is included as the second object in the output list. 
```{r}
graphOut = randomGraph(24, maxWeight=12)
gSeed = graphOut$seed
g = graphOut$graph
g
adjacencyMatrix(g)

h = randomGraph(24, maxWeight=12, seed=gSeed)$graph
identical(g, h)
```

### ```tidyLabels(g, v1=1, v2=2)```
Essentially, attempts to salvage a useable graph from an invalid graph object. A graph and, optionally, two vertices are taken as input; output consists of a list containing a labeled graph object, ```G```, relabeled vertices, ```V1``` and ```V2```, any warnings produced, ```Warn```, and a logical, ```Exit```, indicating whether the function from which ```tidyLabels()``` was called should be exited. To illustrate its use, the lines below are taken from *within* ```is_connected()```.
```{r, eval=F}
  tidied = suppressWarnings(tidyLabels(g, v1, v2))
  g = tidied$G; v1 = tidied$V1; v2 = tidied$V2
  if(!is.null(tidied$Warn)) { warning(tidied$Warn, call.=F) }
  if(tidied$Exit==T) { return(F) }
```

An unlabeled graph is given numbered labels, unless letters are supplied as vertices, in which case graphs with 26 or fewer nodes are given alphabetic labels. When a graph is supplied with integer or integer-coercable vertices, they are interpreted as indexes regardless of the graph's labeling. Other vertices not corresponding to a labeled graph produce a warning and set ```Exit``` to ```TRUE```.
```{r}
names(graph3)
names(tidyLabels(graph3)$G)
names(tidyLabels(graph3, '1', '2')$G)
names(tidyLabels(graph3, 'A', 'B')$G)
tidyLabels(graph3, '7', '8')[-1]

names(graph1)
names(tidyLabels(graph1)$G)
names(tidyLabels(graph1, '1', '2')$G)
names(tidyLabels(graph1, 'A', 'B')$G)
tidyLabels(graph1, 'Y', 'Z')[-1]
```

### ```connectionChecker(g)```
Takes a list-based graph object and outputs a three-column data frame containing every possible vertex pair and a logical indicating whether the pair is connected. Rows are sorted for convenience, and connections are tested via ```is_connected()```.
```{r}
connectionChecker(graph1)
connectionChecker(randomGraph(5)$graph)
```

### ```followVertex(pathList, a)```, ```traceVertex(pathList, a)```, ```getTails(pathList)```, ```getHeads(pathList)```, ```weights(pathList)```, and ```is_linked(pathDn, pathUp, heads, tails)```
These functions primarily take as input a path object, structured similarly to a graph object: a primary list of paths, each a secondary list composed of two vectors: ```$vertices``` and ```$weight```. The first vector contains, in order, all vertices in a given path, while the second contains the summed edge weights along the path. ```followVertex()``` and ```traceVertex()```, used within ```shortest_path()```, take a path object and an adjacency matrix, ```a```, and ```lapply()``` their subroutines, ```followVertexInner()``` and ```traceVertexInner()```. The effect is to take one step forward (backward) from the terminal (initial) vertex of every downward (upward) path, returning an updated path object which takes into account new edge weights. ```getTails()``` (```getHeads()```) then selects the terminal (initial) vertex of each path, yielding a vector, ```tails``` (```heads```). Similarly, ```weights()``` is a convenience wrapper for ```lapply()```, yielding a vector of path weights. Finally, ```is_linked()``` takes the output of these functions to check if the downward and upward paths are linked and, if so, chooses the minimally-weighted linking path. If the paths do not link, ```is_linked()``` returns ```FALSE```; otherwise, it returns a list containing ```linked=TRUE```, the minimum path weight, ```best```, and a vector of the vertices comprising the minimally-weighted linking path, ```bestPath```.
```{r}
a = adjacencyMatrix(graph1)
pathDn = list(list(vertices='A', weight=0))
pathUp = list(list(vertices='F', weight=0))

pathDn = followVertex(pathDn, a)
pathDn
pathDn = followVertex(pathDn, a)
pathDn
tails = getTails(pathDn)
tails

pathUp = traceVertex(pathUp, a)
pathUp
pathUp = traceVertex(pathUp, a)
pathUp
heads = getHeads(pathUp)
heads

weights(pathDn)
is_linked(pathDn, pathUp, heads, tails)
```

## Predicate functions

### ```is_valid(g, requireLabels=TRUE)```
Validates a graph object to ensure that it meets all of the requirements of the data structure. Specifically, it  
(1) checks that the graph object is a list of lists;  
(2) checks that the vertices are labeled and that the labels are unique;  
(3) checks that each secondary list contains only ```$edges``` and ```$weights``` vectors;  
(4) checks that these vectors are of the appropriate types, integer and numeric;  
(5) checks that all edges point to existing vertices;  
(6) checks that all weights are strictly greater than 0; and  
(7) checks that every edge has a corresponding weight.  
If all of these conditions are met, ```is_valid()``` returns ```TRUE```; otherwise, ```FALSE``` and an informative warning. Optionally, setting ```requireLabels=FALSE``` restrains ```is_valid()``` from checking whether vertices are labeled.
```{r}
is_valid(graph1)                     # valid graph
is_valid(graph2)                     # valid graph
is_valid(graph3)                     # unlabeled graph1
is_valid(graph3, requireLabels=F)    # unlabeled graph1
is_valid(graph4)                     # unlabeled graph2
is_valid(graph8)                     # undirected graph2
is_valid(graph10)                    # list(graph1)
is_valid(graph11)                    # graph1 with non-unique vertex labels
is_valid(graph12)                    # graph1 with misnamed weights vector 
is_valid(graph13)                    # graph1 with non-integer edge vector
is_valid(graph14)                    # graph1 with non-numeric weight vector
is_valid(graph15)                    # graph1 with edge to nonexistent vertex
is_valid(graph16)                    # graph1 with nonpositive weight
is_valid(graph17)                    # graph1 with missing weight vector
```

### ```is_undirected(g, requireLabels=TRUE)```
Checks if a graph object is undirected, meaning that each directed edge from A to Z has a complementary directed edge from Z to A, with equal weights in each direction. Implementation is accomplished by converting the graph object to an adjacency matrix, ```a```, taking the transpose of ```a```, and checking if the two matrices are identical. Unlabeled graphs can be processed with ```requireLabels=FALSE```.
```{r}
is_undirected(graph1)                      # directed valid graph
is_undirected(graph2)                      # directed valid graph
is_undirected(graph3)                      # directed unlabeled graph1
is_undirected(graph3, requireLabels=F)     # directed unlabeled graph1
is_undirected(graph4)                      # directed unlabeled graph2
is_undirected(graph8)                      # undirected graph2
is_undirected(graph9)                      # directed graph8 (one edge weight changed)
is_undirected(graph12)                     # directed graph1 with misnamed weights vector
is_undirected(graph12, requireLabels=F)    # directed graph1 with misnamed weights vector
is_undirected(graph18)                     # undirected unlabeled graph2
is_undirected(graph18, requireLabels=F)    # undirected unlabeled graph2
```

### ```is_isomorphic(g1, g2, requireLabels=TRUE)```
Checks if two graph objects are isomorphic, meaning that all vertices, edges, and weights are identical. Comparison of vertices is based upon labels rather than indexes, unless vertices are unlabeled and ```requireLabels=FALSE```. For labeled graphs, an adjacency matrix is constructed for each and they are compared with ```identical()```. For unlabeled graphs, nested ```for``` loops and ```identical()``` are used to compare the each vertex of ```g1``` to those of ```g2```, with each match removed from the set of comparables in future iterations. If no match is found for a given vertex, the function returns ```FALSE```. This implementation is likely slow for graphs of more than 100 vertices due to the ```for``` loops, with a theoretical maximum number of iterations, $(n^2-n)/2$, if the vertices of ```g1``` and ```g2``` were perfectly reversed.
```{r}
# Ignoring labels:
# graph1 isomorphic with graph3, graph6
# graph2 isomorphic with graph4
# graph5 isomorphic with graph6
# graph7, graph8, graph9 not isomorphic with any graphs
is_isomorphic(graph1, graph1)
is_isomorphic(graph1, graph2)
is_isomorphic(graph1, graph3)
is_isomorphic(graph1, graph3, requireLabels=F)
is_isomorphic(graph1, graph4)
is_isomorphic(graph1, graph4, requireLabels=F)
is_isomorphic(graph1, graph5)
is_isomorphic(graph1, graph6)
is_isomorphic(graph1, graph6, requireLabels=F)
is_isomorphic(graph1, graph7)
is_isomorphic(graph1, graph7, requireLabels=F)
is_isomorphic(graph1, graph8)
is_isomorphic(graph1, graph9)
is_isomorphic(graph2, graph2)
is_isomorphic(graph2, graph3)
is_isomorphic(graph2, graph3, requireLabels=F)
is_isomorphic(graph2, graph4)
is_isomorphic(graph2, graph4, requireLabels=F)
is_isomorphic(graph5, graph6)
is_isomorphic(graph5, graph6, requireLabels=F)
is_isomorphic(graph7, graph7)
is_isomorphic(graph7, graph7, requireLabels=F)
is_isomorphic(graph8, graph8)
is_isomorphic(graph9, graph9)
is_isomorphic(graph10, graph10)
is_isomorphic(graph10, graph10, requireLabels=F)
```

### ```is_connected(g, v1, v2, requireLabels=TRUE, unweighted=FALSE)```
Checks if there exists a path from ```v1``` to ```v2```, returning ```TRUE``` if so, ```FALSE``` otherwise. If the supplied vertices are not found in ```g```, an informative warning is issued. Unlabeled graphs can be processed with ```requireLabels=FALSE```. Implementation involves constructing an adjacency matrix, and taking it to the $1^{st}, 2^{nd}, \dots, n^{th}$ power, where $n$ equals the number of vertices in ```g```. If the ```[v1,v2]``` entry of the $i^{th}$ product matrix is positive, the shortest *unweighted* path is of length $i$; if the [v1,v2] entry of all such product matrices is zero, the vertices are unconnected. Setting ```unweighted=TRUE``` returns this path length as the second element, ```$length_of_shortest_unweighted_path```, in a list. The idea for this approach comes from Exercise 2.4 C, found in the fourth edition of Gilbert Strang's Introduction to Linear Algebra (2009). 
```{r}
is_connected(graph1, 'A', 'F')                                # T
is_connected(graph1, 1, 6)                                    # T
is_connected(graph1, 'F', 'a')                                # F
is_connected(graph1, 'e', 'a')                                # F
is_connected(graph2, 'D', 'N')                                # T
is_connected(graph3, 1, 6)                                    # F + warning
is_connected(graph3, 1, 6, requireLabels=F)                   # T
is_connected(graph3, 1, 6, requireLabels=F, unweighted=T)     # T
is_connected(graph3, '1', '6')                                # F + warning
is_connected(graph3, '1', '6', requireLabels=F)               # T + warning
is_connected(graph3, '1', '6', requireLabels=F, unweighted=T) # T + warning
is_connected(graph3, 'A', 'F')                                # F + warning
is_connected(graph3, 'A', 'F', requireLabels=F)               # T + warning
is_connected(graph4, 3, 5)                                    # F + warning
is_connected(graph4, 3, 5, requireLabels=F)                   # T
is_connected(graph2, 'b', 'a')                                # T
is_connected(graph7, 'x', 'z')                                # F + warning
is_connected(graph1, T, F)                                    # F + warning
is_connected(graph3, 35, 83)                                  # F + warning
is_connected(graph3, 35)                                      # F + warning
is_connected(graph3, 1, 2)                                    # F + warning
is_connected(graph3, 1, 2, requireLabels=F)                   # T
is_connected(graph3, 1, 2, 3)                                 # F + warning
is_connected(graph8, 3, 4)                                    # T
is_connected(graph8, 3, 5)                                    # T
is_connected(graph8, 'A', 'B')                                # T
is_connected(graph8, 'D', 'n')                                # T
is_connected(graph5, 'A', 'B')                                # F

b = randomGraph(1000)$graph
is_connected(b, 1, 1000, unweighted=T)
system.time(is_connected(b, 1, 1000, unweighted=T))
```

## Higher functions

### ```shortest_path(g, v1, v2, requireLabels=TRUE, weight=FALSE)```
Finds the shortest path -- meaning minimally-weighted -- from ```v1``` to ```v2```, if such a path exists. If no unique solution exists, a single path is returned. ```requireLabels=FALSE``` allows processing of unlabeled graphs, while ```weight=TRUE``` converts output from a character vector of vertices to a two-element list comprised of the path vector, ```$shortestPath```, and the path weight, ```$pathWeight```. Alternatively, if no path exists, an empty character vector is returned. The idea is as follows:  
```
(1) Initialize a shortest path length as infinity.   
While upward and downward paths are active (non-NULL):  
| (2) Take one step down from terminal vertices of the downward path.  
| (3) Eliminate initial vertices of the upward path if the edge weight to reach them exceeds  
|  |  (shortest path - min(edge weight to reach terminal vertices).  
| (4) If the graph is directed, eliminate previously traversed terminal vertices.  
| (5) Check for complete paths, choose shortest, compare to shortest path, and update.  
| (6) Take one step up from initial vertices of the upward path.  
| (7) Eliminate terminal vertices of the downward path if the edge weight to reach them exceeds  
|  |  (shortest path - min(edge weight to reach initial vertices).  
| (8) If the graph is directed, eliminate previously traversed initial vertices.  
| (9) Check for complete paths, choose shortest, compare to shortest path, and update.
```

```{r}
shortest_path(graph1, 'A', 'F')                  # A-B-C-E-F
shortest_path(graph2, 'D', 'N', weight=T)        # D-A-B-F-N
shortest_path(graph1, 'F', 'a')                  # character(0) + warning
shortest_path(graph3, 1, 6)                      # warning
shortest_path(graph3, 1, 6, requireLabels=F)     # 1-2-3-5-6
shortest_path(graph3, 'A', 'F')                  # warning
shortest_path(graph3, 'A', 'F', requireLabels=F) # A-B-C-E-F + warning
shortest_path(graph4, 3, 5)                      # warning
shortest_path(graph4, 3, 5, requireLabels=F)     # 3-1-2-4-5
shortest_path(graph2, 'b', 'a')                  # B-D-A
shortest_path(graph7, 'x', 'z')                  # warning
shortest_path(graph1, T, F)                      # warning
shortest_path(graph3, 35, 83)                    # warning
shortest_path(graph3, 35)                        # warning
shortest_path(graph3, 1, 2, 3)                   # warning
shortest_path(graph8, 3, 4, weight=T)            # D-A-B-F
shortest_path(graph8, 3, 5)                      # D-A-N
shortest_path(graph5, 'A', 'B')                  # character(0) + warning
shortest_path(graph8, 3, 2)                      # D-A-B

shortest_path(b, 1, 1000, weight=T)
system.time(shortest_path(b, 1, 1000, weight=T))
```
